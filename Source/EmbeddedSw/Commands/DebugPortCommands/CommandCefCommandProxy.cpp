/*******************************************************************
@copyright COPYRIGHT AND PROPRIETARY RIGHTS NOTICES:

Copyright (C) 2021, an unpublished work by Syncroness, Inc.
All rights reserved.

This material contains the valuable properties and trade secrets of
Syncroness of Westminster, CO, United States of America
embodying substantial creative efforts and confidential information,
ideas and expressions, no part of which may be reproduced or
transmitted in any form or by any means, electronic, mechanical, or
otherwise, including photocopying and recording or in connection
with any information storage or retrieval system, without the prior
written permission of Syncroness.
****************************************************************** */

#include "CommandCefCommandProxy.hpp"
#include "Logging.hpp"
#include "CommandDebugPortRouter.hpp"
#include "CommandGenerator.hpp"
#include "CommandExecutor.hpp"


/**
 * Implementation of Command that processes CEF Commands generated by proxy command generator
 *
 * Note:  CommandBase::importFromCefCommand() sanity checks the internal code matches the
 * proxy command generator code for the size of the request command as a crude check that
 * the two code bases are in synch.
 *
 * Note:  CommandBase:exportToCefCommand() adds information to the response packet to
 * allow the proxy command generator to sanity check the sizes match as a crude check that
 * the definition in the two code bases are in synch.
 */


//! Singleton instantiation of CommandDebugPortRouter
static CommandCefCommandProxy commandCefCommandProxySingleton;


CommandCefCommandProxy& CommandCefCommandProxy::instance()
{
	return commandCefCommandProxySingleton;
}

#if 1
bool CommandCefCommandProxy::execute(CommandBase* p_childCommand)
{
	return false;
}

#else
bool CommandCefCommandProxy::execute(CommandBase* p_childCommand)
{
    bool commandDone = false;
    bool shouldYield = false;
#if 1
    errorCode_t status = errorCode_OK;

    validateChildResponse(p_childCommand, mp_childCommand);

    while (shouldYield == false)
    {
        switch (m_commandState)
        {
            case commandStateCommandEntry:
            {
                m_commandState = commandStateGetCefCommandRequest;
                break;
            }
            case commandStateGetCefCommandRequest:
            {
            	mp_cefCommand = CommandDebugPortRouter::instance().checkoutCefCommandBuffer();
            	if (mp_cefCommand == nullptr)
            	{
            		// No packet to work on; exit and try again later
            		shouldYield = true;
            		break;
            	}

            	// We have a CEF command to work on; process it
            	m_commandState = commandStateProcessCommand;

                break;
            }

            case commandStateProcessCommand:
            {
            	bool allocatableCommand = false;
            	mp_childCommand = CommandGenerator::instance().allocateCommand(mp_cefCommand->m_cefCommandHeader.m_commandOpCode, allocatableCommand);

            	// Was the command allocatable?  If not, need to return an error as not setup correctly to allocate the command
            	if (allocatableCommand == false)
            	{
            		status = errorCode_RequestedCefProxyCommandNotAllocatable;
                	m_commandState = commandStateReportError;
                	break;
            	}

            	if (mp_childCommand == nullptr)
            	{
            		// Exit and try again later
            		shouldYield = true;
            		break;
            	}

            	// Set this command as the parent of the command we allocated
            	// (so we come back to this command when child is finished executing)
            	mp_childCommand->setParentCommand(this);

            	// We have a command, now import the data to the command
            	status = mp_childCommand->importFromCefCommand(mp_cefCommand);

            	if (status != errorCode_OK)
            	{
            		// we failed to import the command; no choice but to report an error back to proxy command generator
                	m_commandState = commandStateReportError;
                	break;
            	}

            	// Schedule the command to be executed
            	CommandExecutor::instance().addCommandToQueue(mp_childCommand);

            	// Wait for the child response
            	m_commandState = commandStateWaitForChildResponse;
        		shouldYield = true;

            	break;
            }

            case commandStateWaitForChildResponse:
            {
            	// We have a valid child response.  Now export the data to form a CEF Command Response
            	status = mp_childCommand->exportToCefCommand(mp_cefCommand);

            	if (status != errorCode_OK)
            	{
            		// we failed to import the command; no choice but to report an error back to proxy command generator
                	m_commandState = commandStateReportError;
                	break;
            	}

            	// Done processing the command; release resources (which triggers the transmit of the CEF command back to proxy command generator)
            	// Note:  we must not yield as next time we enter the state machine the expected child response will not be correct!
            	// The child response is set correctly in commandStateSendAndReleaseResources
            	m_commandState = commandStateSendAndReleaseResources;

            	break;
            }

            case commandStateSendAndReleaseResources:
            {
				// We are all done with the child command (if there was one issued)
            	if (mp_childCommand != nullptr)
            	{
					CommandGenerator::instance().freeCommand(mp_childCommand);
					// Must set child command to nullptr or else validateChildResponse() will fail.
					mp_childCommand = nullptr;
            	}

            	// Return the checked out CEF Command buffer (which triggers the transmit of the CEF command back to proxy command generator)
            	CommandDebugPortRouter::instance().returnCefCommandBuffer(mp_cefCommand, mp_cefCommand->m_cefCommandHeader.m_commandNumBytes);
            	mp_cefCommand = nullptr;

            	// Look for another Cef Command to process next time we have a chance to run
            	m_commandState = commandStateGetCefCommandRequest;
        		shouldYield = true;

            	break;
            }

            case commandStateReportError:
            {
                LOG_ERROR(Logging::LogModuleIdCefDebugCommands, "CEF Command Handling Failed.  Status={:d}, OpCode={:d}", m_commandState, mp_cefCommand->m_cefCommandHeader.m_commandOpCode);

            	// Report the error back to proxy command generator
            	mp_cefCommand->m_cefCommandHeader.m_commandErrorCode = status;

            	// There is no response payload other than the header
            	mp_cefCommand->m_cefCommandHeader.m_commandNumBytes = sizeof(mp_cefCommand->m_cefCommandHeader);

            	// We have reported what error conditions we can, so now send the CEF command back to proxy command generator
            	m_commandState = commandStateSendAndReleaseResources;

            	break;
            }

            case commandStateCommandComplete:		// Proxy Command Handling should run forever
            default:
            {
                // If we get here, we've lost our mind.
                LOG_FATAL(Logging::LogModuleIdCefDebugCommands, "CommandCefCommandProxy Unhandled command state {:d}", m_commandState);
                shouldYield = true;
                commandDone = true;
                break;
            }
        }
    }
#endif
    return commandDone;
}
#endif
