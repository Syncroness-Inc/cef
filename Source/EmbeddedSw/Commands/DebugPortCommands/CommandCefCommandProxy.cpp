/*******************************************************************
 @copyright COPYRIGHT AND PROPRIETARY RIGHTS NOTICES:

 Copyright (C) 2021, an unpublished work by Syncroness, Inc.
 All rights reserved.

 This material contains the valuable properties and trade secrets of
 Syncroness of Westminster, CO, United States of America
 embodying substantial creative efforts and confidential information,
 ideas and expressions, no part of which may be reproduced or
 transmitted in any form or by any means, electronic, mechanical, or
 otherwise, including photocopying and recording or in connection
 with any information storage or retrieval system, without the prior
 written permission of Syncroness.
 ****************************************************************** */

#include "CommandCefCommandProxy.hpp"
#include "Logging.hpp"
#include "CommandDebugPortRouter.hpp"
#include "CommandGenerator.hpp"
#include "CommandExecutor.hpp"

/**
 * Implementation of Command that processes CEF Commands generated by proxy command generator
 *
 * Note:  CommandBase::importFromCefCommand() sanity checks the internal code matches the
 * proxy command generator code for the size of the request command as a crude check that
 * the two code bases are in synch.
 *
 * Note:  CommandBase:exportToCefCommand() adds information to the response packet to
 * allow the proxy command generator to sanity check the sizes match as a crude check that
 * the definition in the two code bases are in synch.
 */

//! Singleton instantiation of CommandDebugPortRouter
static CommandCefCommandProxy commandCefCommandProxySingleton;

CommandCefCommandProxy& CommandCefCommandProxy::instance()
{
    return commandCefCommandProxySingleton;
}

bool CommandCefCommandProxy::execute(CommandBase *p_childCommand)
{
    bool commandDone = false;
    bool shouldYield = false;

    errorCode_t status = errorCode_OK;

    if (m_commandState != commandStateWaitForChildResponse)
    {
        // If not expecting a child response, confirm that it is a nullptr
        validateNullChildResponse(p_childCommand);
    }

    while (shouldYield == false)
    {
        switch (m_commandState)
        {
        case commandStateCommandEntry:
        {
            m_commandState = commandStateGetCefCommandRequest;
            break;
        }
        case commandStateGetCefCommandRequest:
        {
            mp_cefBuffer = CommandDebugPortRouter::instance().checkoutCefCommandProxyProcessingBuffer();
            if (mp_cefBuffer == nullptr)
            {
                // No packet to work on; exit and try again later
                shouldYield = true;
                break;
            }

            // The first element of every command MUST be a command header
            mp_cefCommandHeader = (cefCommandHeader_t*) mp_cefBuffer->getBufferStartAddress();
            if (mp_cefCommandHeader == nullptr)
            {
                LOG_FATAL(Logging::LogModuleIdCefInfrastructure, "Programming Error:  Passed nullptr for Cef Command",
                        0, 0, 0);
            }

            // We have a CEF command to work on; process it
            m_commandState = commandStateProcessCommand;

            break;
        }

        case commandStateProcessCommand:
        {
            bool allocatableCommand = false;
            mp_childCommand = CommandGenerator::instance().allocateCommand(mp_cefCommandHeader->m_commandOpCode, allocatableCommand);

            // Was the command allocatable?  If not, need to return an error as not setup correctly to allocate the command
            if (allocatableCommand == false)
            {
                status = errorCode_RequestedCefProxyCommandNotAllocatable;
                m_commandState = commandStateReportError;
                break;
            }

            if (mp_childCommand == nullptr)
            {
                // Exit and try again later
                shouldYield = true;
                break;
            }

            // Set this command as the parent of the command we allocated
            // (so we come back to this command when child is finished executing)
            mp_childCommand->setParentCommand(this);

            // We have a command, now import the data to the command
            status = mp_childCommand->importFromCefCommand(mp_cefCommandHeader,
                                                           mp_cefBuffer->getNumberOfValidBytes());

            if (status != errorCode_OK)
            {
                // we failed to import the command; no choice but to report an error back to proxy command generator
                m_commandState = commandStateReportError;
                break;
            }

            // Schedule the command to be executed
            CommandExecutor::instance().addCommandToQueue(mp_childCommand);

            // Wait for the child response
            m_commandState = commandStateWaitForChildResponse;
            shouldYield = true;

            break;
        }

        case commandStateWaitForChildResponse:
        {
            /**
             * CommandCefCommandProxy is called continuously from the CommandExecutor.
             * It may take many loops through the CommandExecutor before we have a
             * child response.  So need to just keeping waiting until we do have a child response.
             */
            if (mp_childCommand == nullptr)
            {
                shouldYield = true;
                break;
            }

            // We have a child response...process it by exporting the data to the Cef command
            // so we can send results/response back to the proxy command generator.
            status = mp_childCommand->exportToCefCommand(mp_cefCommandHeader);

            if (status != errorCode_OK)
            {
                // we failed to import the command; no choice but to report an error back to proxy command generator
                m_commandState = commandStateReportError;
                break;
            }

            // Done processing the command; release resources (which triggers the transmit of the CEF command back to proxy command generator)
            // Note:  we must not yield as next time we enter the state machine the expected child response will not be correct!
            // The child response is set correctly in commandStateSendAndReleaseResources
            m_commandState = commandStateSendAndReleaseResources;

            break;
        }

        case commandStateSendAndReleaseResources:
        {
            // We are all done with the child command (if there was one issued) so release it
            if (mp_childCommand != nullptr)
            {
                CommandGenerator::instance().freeCommand(mp_childCommand);
                // Must set child command to nullptr or else validateChildResponse() will fail.
                mp_childCommand = nullptr;
            }

            // Note:  The Command header has been updated by the export command
            // Update number of valid bytes in the command response header
            uint32_t commandNumBytes = mp_cefCommandHeader->m_commandNumBytes;
            errorCode_t setValidBytesStatus =
                    mp_cefBuffer->setNumberOfValidBytes(commandNumBytes);
            if (setValidBytesStatus != errorCode_OK)
            {
                // There is memory corruption as we added more bytes to the buffer than we had room!
                LOG_FATAL(Logging::LogModuleIdCefInfrastructure, "Memory corruption from adding to many bytes to buffer! {:d} {:d} {:d}",
                        setValidBytesStatus, commandNumBytes, mp_cefBuffer->getMaxBufferSizeInBytes());
            }

            // Return the checked out CEF Command buffer (which triggers the transmit of the CEF command back to proxy command generator)
            CommandDebugPortRouter::instance().checkinCefCommandProxyProcessingBuffer(mp_cefBuffer);
            mp_cefCommandHeader = nullptr;

            // Look for another Cef Command to process next time we have a chance to run
            m_commandState = commandStateGetCefCommandRequest;
            shouldYield = true;

            break;
        }

        case commandStateReportError:
        {
            LOG_ERROR(Logging::LogModuleIdCefInfrastructure, "CEF Command Handling Failed.  Status={:d}, OpCode={:d}",
                    m_commandState, mp_cefCommandHeader->m_commandOpCode, 0);

            // Report the error back to proxy command generator
            mp_cefCommandHeader->m_commandErrorCode = status;

            // There is no response payload other than the header
            mp_cefCommandHeader->m_commandNumBytes = sizeof(cefCommandHeader_t);

            // We have reported what error conditions we can, so now send the CEF command back to proxy command generator
            m_commandState = commandStateSendAndReleaseResources;

            break;
        }

        case commandStateCommandComplete:// Proxy Command Handling should run forever
        default:
        {
            // If we get here, we've lost our mind.
            LOG_FATAL(Logging::LogModuleIdCefInfrastructure, "CommandCefCommandProxy Unhandled command state {:d}",
                    m_commandState, 0, 0);
            shouldYield = true;
            commandDone = true;
            break;
        }
        }
    }

    return commandDone;
}

